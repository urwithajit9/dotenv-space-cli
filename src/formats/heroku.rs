//! Heroku Config Vars converter
//!
//! Converts environment variables to Heroku CLI commands for setting config vars.

use crate::core::converter::{ConvertOptions, Converter};
use anyhow::Result;
use std::collections::HashMap;

/// Heroku Config Vars converter
///
/// ✅ CLIPPY FIX: Uses `#[derive(Default)]` instead of manual implementation
#[derive(Debug, Clone, Default)]
pub struct HerokuConfigConverter {
    // Optional Heroku app name (can be specified in commands)
    pub app_name: Option<String>,
}

// ✅ CLIPPY FIX: Removed manual impl Default (using #[derive(Default)])

impl HerokuConfigConverter {
    // Create converter with specific app name
    pub fn new(app_name: String) -> Self {
        Self {
            app_name: Some(app_name),
        }
    }

    // Create converter without app name (user must specify with --app flag)
    pub fn without_app() -> Self {
        Self { app_name: None }
    }
}

impl Converter for HerokuConfigConverter {
    fn convert(&self, vars: &HashMap<String, String>, options: &ConvertOptions) -> Result<String> {
        let filtered = options.filter_vars(vars);
        let mut output = String::new();

        output.push_str("#!/bin/bash\n");
        output.push_str("# Heroku Config Vars\n");
        output.push_str("# Generated by evnx\n");
        output.push_str("#\n");
        output.push_str("# Usage:\n");

        if self.app_name.is_some() {
            output.push_str("#   bash heroku-config.sh\n");
        } else {
            output.push_str("#   bash heroku-config.sh --app YOUR_APP_NAME\n");
        }

        output.push_str("#\n");
        output.push_str("# Or set variables individually:\n");
        output.push_str("#   heroku config:set KEY=VALUE --app YOUR_APP_NAME\n");
        output.push('\n');

        // App name flag
        let app_flag = if let Some(ref app) = self.app_name {
            format!(" --app {}", app)
        } else {
            " --app ${HEROKU_APP:-YOUR_APP_NAME}".to_string()
        };

        output.push_str("set -e\n\n");

        // Generate config:set commands
        output.push_str("echo \"Setting Heroku config vars...\"\n\n");

        for (key, value) in filtered.iter() {
            let transformed_key = options.transform_key(key);
            let transformed_value = options.transform_value(value);

            // Escape value for shell
            let escaped_value = transformed_value
                .replace('\\', "\\\\")
                .replace('"', "\\\"")
                .replace('$', "\\$")
                .replace('`', "\\`");

            output.push_str(&format!(
                "heroku config:set {}=\"{}\"{}",
                transformed_key, escaped_value, app_flag
            ));
            output.push_str(" || echo \"Failed to set ");
            output.push_str(&transformed_key);
            output.push_str("\"\n");
        }

        output.push_str("\necho \"✓ Config vars set successfully\"\n");

        // Add instructions for verification
        output.push_str("\n# Verify settings:\n");
        output.push_str(&format!("# heroku config{}\n", app_flag));

        Ok(output)
    }

    fn name(&self) -> &str {
        "heroku"
    }

    fn description(&self) -> &str {
        "Heroku Config Vars (heroku CLI commands)"
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_converter() {
        let converter = HerokuConfigConverter::default();
        assert!(converter.app_name.is_none());
    }

    #[test]
    fn test_converter_with_app() {
        let converter = HerokuConfigConverter::new("my-app".to_string());
        assert_eq!(converter.app_name, Some("my-app".to_string()));
    }

    #[test]
    fn test_converter_without_app() {
        let converter = HerokuConfigConverter::without_app();
        assert!(converter.app_name.is_none());
    }

    #[test]
    fn test_convert_basic() {
        let mut vars = HashMap::new();
        vars.insert("DATABASE_URL".to_string(), "postgresql://...".to_string());
        vars.insert("SECRET_KEY".to_string(), "secret123".to_string());

        let converter = HerokuConfigConverter::new("test-app".to_string());
        let options = ConvertOptions::default();
        let result = converter.convert(&vars, &options).unwrap();

        assert!(result.contains("heroku config:set"));
        assert!(result.contains("DATABASE_URL"));
        assert!(result.contains("SECRET_KEY"));
        assert!(result.contains("--app test-app"));
    }

    #[test]
    fn test_convert_without_app() {
        let mut vars = HashMap::new();
        vars.insert("KEY".to_string(), "value".to_string());

        let converter = HerokuConfigConverter::without_app();
        let options = ConvertOptions::default();
        let result = converter.convert(&vars, &options).unwrap();

        assert!(result.contains("--app ${HEROKU_APP:-YOUR_APP_NAME}"));
    }

    #[test]
    fn test_convert_with_special_chars() {
        let mut vars = HashMap::new();
        vars.insert(
            "KEY".to_string(),
            "value with \"quotes\" and $vars".to_string(),
        );

        let converter = HerokuConfigConverter::default();
        let options = ConvertOptions::default();
        let result = converter.convert(&vars, &options).unwrap();

        // Should escape special characters
        assert!(result.contains("\\\""));
        assert!(result.contains("\\$"));
    }

    #[test]
    fn test_converter_name() {
        let converter = HerokuConfigConverter::default();
        assert_eq!(converter.name(), "heroku");
    }

    #[test]
    fn test_converter_description() {
        let converter = HerokuConfigConverter::default();
        assert!(!converter.description().is_empty());
    }
}
