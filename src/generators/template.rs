//! Template builder for assembling `.env.example` content.
//!
//! This module provides a fluent builder API to combine stack and service
//! generators into a complete environment variable template.

use anyhow::Result;
use std::collections::HashMap;

use crate::generators::{EnvVar, ServiceGenerator, StackGenerator};

/// Builder for assembling environment variable templates.
///
/// # Example
///
/// ```no_run
/// use evnx::config::registry;
/// use evnx::generators::template::EnvTemplateBuilder;
///
/// let reg = registry();
/// let stack = reg.get_stack("python").unwrap();
/// let services = vec![reg.get_service("postgresql").unwrap()];
///
/// let content = EnvTemplateBuilder::new()
///     .with_stack(stack)
///     .with_services(services)
///     .build()
///     .unwrap();
/// ```
pub struct EnvTemplateBuilder<'a> {
    stack: Option<&'a dyn StackGenerator>,
    services: Vec<&'a dyn ServiceGenerator>,
    include_footer: bool,
}

impl<'a> EnvTemplateBuilder<'a> {
    /// Create a new empty builder.
    #[must_use]
    pub fn new() -> Self {
        Self {
            stack: None,
            services: Vec::new(),
            include_footer: true,
        }
    }

    /// Set the primary stack generator.
    #[must_use]
    pub fn with_stack(mut self, stack: &'a dyn StackGenerator) -> Self {
        self.stack = Some(stack);
        self
    }

    /// Add service generators.
    #[must_use]
    pub fn with_services(mut self, services: Vec<&'a dyn ServiceGenerator>) -> Self {
        self.services = services;
        self
    }

    /// Control whether to include the generation footer comment.
    #[must_use]
    pub fn include_footer(mut self, include: bool) -> Self {
        self.include_footer = include;
        self
    }

    /// Generate the complete `.env.example` content.
    ///
    /// Variables are grouped by category, with stack vars first, then services.
    pub fn build(self) -> Result<String> {
        let mut content = String::new();
        let mut vars_by_category: HashMap<Option<String>, Vec<EnvVar>> = HashMap::new();

        // Collect stack variables
        if let Some(stack) = self.stack {
            for var in stack.default_env_vars() {
                vars_by_category
                    .entry(var.category.clone())
                    .or_default()
                    .push(var);
            }
        }

        // Collect service variables
        for service in &self.services {
            for var in service.env_vars() {
                vars_by_category
                    .entry(var.category.clone())
                    .or_default()
                    .push(var);
            }
        }

        // Sort categories: None first, then alphabetically
        let mut categories: Vec<_> = vars_by_category.keys().collect();
        // categories.sort_by(|a, b| a.cmp(b));
        categories.sort();

        for category in categories {
            // Print category header if present
            if let Some(cat_name) = category {
                content.push_str(&format!("\n# {}\n", cat_name));
            }

            // Print variables in this category
            if let Some(vars) = vars_by_category.get(category) {
                for var in vars {
                    content.push_str(&var.to_example_line());
                    content.push('\n');
                }
            }
            content.push('\n');
        }

        // Add generation footer
        if self.include_footer {
            content.push_str(&format!(
                "# Generated by dotenv-space v{} on {}\n",
                env!("CARGO_PKG_VERSION"),
                chrono::Local::now().format("%Y-%m-%d")
            ));
        }

        Ok(content)
    }
}

impl Default for EnvTemplateBuilder<'_> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::generators::{ServiceGenerator, StackGenerator};

    struct TestStack;
    impl StackGenerator for TestStack {
        fn id(&self) -> &'static str {
            "test"
        }
        fn display_name(&self) -> &'static str {
            "Test"
        }
        fn default_env_vars(&self) -> Vec<EnvVar> {
            vec![EnvVar::new("APP_ENV", "development").with_category("Application")]
        }
    }

    struct TestService;
    impl ServiceGenerator for TestService {
        fn id(&self) -> &'static str {
            "test_svc"
        }
        fn display_name(&self) -> &'static str {
            "Test Service"
        }
        fn env_vars(&self) -> Vec<EnvVar> {
            vec![EnvVar::new("API_KEY", "xxx").with_category("Auth")]
        }
    }

    #[test]
    fn test_builder_basic() {
        let content = EnvTemplateBuilder::new()
            .with_stack(&TestStack)
            .with_services(vec![&TestService])
            .include_footer(false)
            .build()
            .unwrap();

        assert!(content.contains("APP_ENV=development"));
        assert!(content.contains("API_KEY=xxx"));
        assert!(content.contains("# Application"));
        assert!(content.contains("# Auth"));
    }

    #[test]
    fn test_builder_no_footer() {
        let content = EnvTemplateBuilder::new()
            .include_footer(false)
            .build()
            .unwrap();
        assert!(!content.contains("Generated by dotenv-space"));
    }
}
